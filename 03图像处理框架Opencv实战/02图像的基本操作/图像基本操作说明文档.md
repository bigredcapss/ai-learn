# OpenCV图像基本操作说明文档

## 目录
1. [环境配置](#环境配置)
2. [图像读取与显示](#图像读取与显示)
3. [视频读取与处理](#视频读取与处理)
4. [图像基本操作](#图像基本操作)
5. [颜色通道处理](#颜色通道处理)
6. [边界填充](#边界填充)
7. [数值计算](#数值计算)
8. [图像融合](#图像融合)
9. [文件说明](#文件说明)

## 环境配置

### 必需环境
- **Anaconda**: https://www.anaconda.com/download/
- **Python OpenCV**: 可通过pip或conda安装
- **开发环境**: 推荐使用支持debug的IDE（如PyCharm、VS Code等）

### 安装命令
```bash
pip install opencv-python
pip install matplotlib
pip install numpy
```

## 图像读取与显示

### 基本图像读取
```python
import cv2
import matplotlib.pyplot as plt
import numpy as np

# 读取图像（默认彩色模式）
img = cv2.imread('cat.jpg')

# 读取灰度图像
img_gray = cv2.imread('cat.jpg', cv2.IMREAD_GRAYSCALE)
```

### 图像显示方法
```python
# 方法1：使用OpenCV显示
def cv_show(name, img):
    cv2.imshow(name, img)
    cv2.waitKey(0)  # 等待按键
    cv2.destroyAllWindows()

# 方法2：使用matplotlib显示
plt.imshow(img)
plt.show()
```

### 图像属性
```python
print(f"图像形状: {img.shape}")  # (高度, 宽度, 通道数)
print(f"图像大小: {img.size}")   # 像素总数
print(f"数据类型: {img.dtype}")  # uint8
```

### 图像保存
```python
cv2.imwrite('mycat.png', img)
```

## 视频读取与处理

### 视频文件读取
```python
# 读取视频文件
vc = cv2.VideoCapture('test.mp4')

# 检查是否成功打开
if vc.isOpened():
    open, frame = vc.read()
else:
    open = False
```

### 视频处理循环
```python
while open:
    ret, frame = vc.read()
    if frame is None:
        break
    if ret == True:
        # 转换为灰度图
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        cv2.imshow('result', gray)
        # 按ESC键退出
        if cv2.waitKey(100) & 0xFF == 27:
            break

vc.release()
cv2.destroyAllWindows()
```

### 摄像头捕获
```python
# 捕获摄像头（0表示默认摄像头）
cap = cv2.VideoCapture(0)
```

## 图像基本操作

### 图像截取
```python
# 截取图像的一部分 [y:y+h, x:x+w]
img = cv2.imread('cat.jpg')
cat_region = img[0:50, 0:200]  # 截取左上角区域
cv_show('cat_region', cat_region)
```

### 图像缩放
```python
# 方法1：指定尺寸
resized = cv2.resize(img, (500, 414))

# 方法2：按比例缩放
resized = cv2.resize(img, (0, 0), fx=2, fy=2)  # 放大2倍
resized = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)  # 缩小一半
```

## 颜色通道处理

### 通道分离与合并
```python
# 分离BGR通道
b, g, r = cv2.split(img)

# 合并通道
img_merged = cv2.merge((b, g, r))
```

### 单通道显示
```python
# 只保留红色通道
cur_img = img.copy()
cur_img[:,:,0] = 0  # 蓝色通道置0
cur_img[:,:,1] = 0  # 绿色通道置0
cv_show('Red_Channel', cur_img)

# 只保留绿色通道
cur_img = img.copy()
cur_img[:,:,0] = 0  # 蓝色通道置0
cur_img[:,:,2] = 0  # 红色通道置0
cv_show('Green_Channel', cur_img)

# 只保留蓝色通道
cur_img = img.copy()
cur_img[:,:,1] = 0  # 绿色通道置0
cur_img[:,:,2] = 0  # 红色通道置0
cv_show('Blue_Channel', cur_img)
```

## 边界填充

### 边界填充方法
```python
top_size, bottom_size, left_size, right_size = (50, 50, 50, 50)

# 复制法：复制最边缘像素
replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, 
                              borderType=cv2.BORDER_REPLICATE)

# 反射法：对图像像素在两边进行复制
reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,
                            cv2.BORDER_REFLECT)

# 反射法101：以最边缘像素为轴对称
reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, 
                               cv2.BORDER_REFLECT_101)

# 外包装法
wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, 
                         cv2.BORDER_WRAP)

# 常量法：用常数值填充
constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,
                             cv2.BORDER_CONSTANT, value=0)
```

### 边界填充类型说明
- **BORDER_REPLICATE**: 复制法，复制最边缘像素
- **BORDER_REFLECT**: 反射法，对图像像素在两边进行复制，如：fedcba|abcdefgh|hgfedcb
- **BORDER_REFLECT_101**: 反射法，以最边缘像素为轴对称，如：gfedcb|abcdefgh|gfedcba
- **BORDER_WRAP**: 外包装法，如：cdefgh|abcdefgh|abcdefg
- **BORDER_CONSTANT**: 常量法，用指定常数值填充

## 数值计算

### 像素值运算
```python
# 直接相加（会溢出，相当于 % 256）
img_cat = cv2.imread('cat.jpg')
img_cat2 = img_cat + 10

# 使用cv2.add避免溢出
result = cv2.add(img_cat, img_cat2)
```

### 注意事项
- 直接使用 `+` 运算符可能导致像素值溢出（超过255）
- 使用 `cv2.add()` 函数可以自动处理溢出问题，超过255的值会被截断为255

## 图像融合

### 图像融合方法
```python
# 读取两张图像
img_cat = cv2.imread('cat.jpg')
img_dog = cv2.imread('dog.jpg')

# 调整图像尺寸使其一致
img_dog = cv2.resize(img_dog, (500, 414))

# 加权融合
res = cv2.addWeighted(img_cat, 0.4, img_dog, 0.6, 0)
# 参数说明：图像1, 权重1, 图像2, 权重2, 偏置值
```

### 融合参数说明
- `alpha`: 第一张图像的权重
- `beta`: 第二张图像的权重
- `gamma`: 偏置值（通常为0）
- 权重和通常为1（alpha + beta = 1）

## 文件说明

### 图像文件
- `cat.jpg`, `dog.jpg`: 测试用的猫狗图像
- `lena.jpg`, `lena_img.png`: 经典的Lena测试图像
- `mycat.png`: 保存的灰度猫图像
- `AM.png`: 字母A和M的测试图像

### 处理结果图像
- `canny_*.png`: Canny边缘检测结果
- `sobel_*.png`: Sobel算子处理结果
- `scharr.png`: Scharr算子处理结果
- `contours*.png`: 轮廓检测结果
- `Pyramid_*.png`: 图像金字塔结果

### 视频文件
- `test.mp4`: 测试视频文件

## 使用建议

1. **图像读取**: 注意OpenCV读取的是BGR格式，与RGB不同
2. **内存管理**: 处理大图像时注意内存使用
3. **数据类型**: 图像数据类型通常为uint8（0-255）
4. **错误处理**: 读取文件前检查文件是否存在
5. **性能优化**: 对于大量图像处理，考虑使用批处理

## 常见问题

### Q: 为什么图像显示颜色不对？
A: OpenCV使用BGR格式，而matplotlib使用RGB格式，需要转换：
```python
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_rgb)
```

### Q: 如何处理图像溢出？
A: 使用cv2.add()而不是直接相加：
```python
# 错误方式
result = img1 + img2

# 正确方式
result = cv2.add(img1, img2)
```

### Q: 如何保存图像？
A: 使用cv2.imwrite()，注意路径和格式：
```python
cv2.imwrite('output.jpg', img)  # 保存为JPEG
cv2.imwrite('output.png', img)  # 保存为PNG
```
